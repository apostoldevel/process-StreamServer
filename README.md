Потоковый сервер (Streaming server)
-
**Модуль** для [Апостол](https://github.com/ufocomp/apostol-aws).

Установка
-
Следуйте указаниям по сборке и установке [Апостол](https://github.com/ufocomp/apostol-aws#%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-%D0%B8-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0)

Описание
-
**Потоковый сервер** предназначени для приёма и передачи данных с мобильных устройств и интернет вещей.

Протокол
-

Протокол разработан без привязки к определенному устройству.

### Терминология

* **Пакет** – единица передачи информации на уровне канала передачи данных.

* **Команда** – единица передачи информации прикладного уровня. Если команда длинная, она разбивается на пакеты.

Команда состоит из объединенных данных пакетов. Объединение выполняется от начального до конечного пакета в порядке возрастания номера пакета.

Пакеты команды могут приходить в хаотичном порядке. Не полностью собранная команда отбрасывается по таймауту.

Если тип устройства неопределенный и идентификатор пустой, то это широковещательный пакет.

#### Общая структура пакета

 Поле | Размер поля | Тип данных | Назначение, примечания 
----- | ----------- | ---------- | ----------------------
 Длина пакета | 1 или 2 байта. | length | Длина всего пакета (все поля кроме поля длины) в байтах.
 Версия протокола | 1 байт | uint8 | Текущая версия = 1.
 Параметры | 1 байт | bin | 0 бит – начальный пакет команды; 1 бит – конечный пакет команды; 2 бит – пакет к счетчику; 3 бит – ответ на запрос; 4 бит – команда упакована (Zlib); 5 бит – команда зашифрована (AES 128); 6 бит – квитанция
 Тип устройства | 1 байт | device_type | 0x00 - IoT, 0x01 - Mobile.
 Размер серийного номера | 1 байт | uint8 | В байтах.
 Серийный номер | ... | utf8 | Пример: ABC-012345678
 Номер команды | 1 байт | uint8 | Циклически от 0 до 255. При ответе на запрос подставляется из запроса.
 Номер пакета | 1 байт | uint8 | Номер пакета команды 0-255 (для каждой команды от 0).
 Данные пакета | ... | ... |
 Контрольная сумма | 2 байта | crc16 | Все поля кроме контрольной суммы.
 
#### Структура команды от устройства

 Поле | Размер поля | Тип данных | Назначение, примечания 
----- | ----------- | ---------- | ----------------------
 Метка времени | 4 байта | time | Текущее время счетчика: 0 – неопределенное время, 1 – ошибка времени.
 Тип команды | 1 байт | uint8 | 0x01 – Текущее состояние истройства и т.д. 
 Код ошибки | 1 байт | uint8 | См. ниже. Если есть ошибка, то поле “Данные” отсутствует.
 Данные команды | ... | ... | Формат и размер зависит от типа команды.

Тип команды ответа на запрос равен типу команды запроса со сброшенным старшим битом.
Например: запрос 0x81 – ответ 0x01, запрос 0x82 – ответ 0x02 и т.д.

Код ошибки:
 * 0 - Нет ошибки;
 * 1 - Неопределенная ошибка;
 * 2 - Неизвестная команда;
 * 3 - Некорректный формат команды;
 * 4 - Некорректные параметры команды.

#### Структура команды к устройству

 Поле | Размер поля | Тип данных | Назначение, примечания 
----- | ----------- | ---------- | ----------------------
 Тип команды | 1 байт | uint8 | 0x82 – запрос прозрачных данных и т.д. 
 Данные команды | ... | ... | Формат и размер зависит от типа команды.

#### Пример пакета

Команда "Текущее состояние устройства". Номер команды `0xF0`. Серийный номер `1234`. Время - `1 января 2020 года 08:09:10`. Нет ошибок. Условные данные с датой `1 января 2020 года 08:09:00`.

Команда в шестнадцатеричном виде:
````
1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
1E 01 03 06 04 31 32 33 34 F0 00 A6 53 0C 5E 01 00 00 00 04 00 00 00 00 02 9C 53 0C 5E 3E C7
│  │  │  │  │  │           │  │  ├──┐        │  │  │     │  │           │  │           └─ CRC16
│  │  │  │  │  │           │  │  │  │        │  │  │     │  │           │  └─ Время последней синхронизации времени: 1 января 2020 года 08:09:00
│  │  │  │  │  │           │  │  │  │        │  │  │     │  │           └─ Тип последней синхронизации времени: 0x02 - NTP синхронизация
│  │  │  │  │  │           │  │  │  │        │  │  │     │  └─ Время последнего конфигурирования: 0 – конфигурирование не проводилось
│  │  │  │  │  │           │  │  │  │        │  │  │     └─ Текущий тариф: 4
│  │  │  │  │  │           │  │  │  │        │  │  └─ Состояние: 0 (2 байта)
│  │  │  │  │  │           │  │  │  │        │  └─ Код ошибки: 0 (Нет ошибки)
│  │  │  │  │  │           │  │  │  │        └─ Тип команды: 0x01 (Текущее состояние)
│  │  │  │  │  │           │  │  │  └─ Метка времени: 1 января 2020 года 08:09:10
│  │  │  │  │  │           │  │  └─ Данные пакета: [A6 53 0C 5E 01 00 00 00 04 00 00 00 00 02 9C 53 0C 5E]
│  │  │  │  │  │           │  └─ Номер пакета
│  │  │  │  │  │           └─ Номер команды
│  │  │  │  │  └─ Серийный номер
│  │  │  │  └─ Размер идентификатора
│  │  │  └─ Тип устройства
│  │  └─ Параметры
│  └─ Версия протокола
└─ Длина пакета: 1E - 30 байт (все поля кроме поля длины).
````

### Типы данных

* Все типы данных передаются младшим байтом вперед.

**uint8**, **uint16**, **uint32**, **uint64** – тип данных, целочисленный беззнаковый двоичный, длиной 1, 2, 4, 8 байт соответственно.

**usmallint8** – целочисленный беззнаковый двоичный, длиной 6 байт. Аналогичен типу uint64 без двух старших байтов.

**usmallint4** – целочисленный беззнаковый двоичный, длиной 3 байта. Аналогичен типу uint32 без старшего байта.

**int8**, **int16** – тип данных, целочисленный знаковый двоичный, длиной, 1 или 2, байта соответственно (дополнительный код)

**bool** – логический тип, 1 байт, 0 - false, 1 - true

**time** - тип данных для отображения времени, принятый в UNIX-системах - time_t (uint32, количество секунд с 1970-01-01 00:00:00). Локальное время.

**time_sync** – тип синхронизации времени: 
  * 0x00 - Не определенная; 
  * 0x01 - Ручная синхронизация с помощью команд "Установка времени"; 
  * 0x02 - NTP синхронизация.

**device_type** - Тип устройства:
  * 0x00 - IoT (Интернет вещь)
  * 0x01 - Мобильное устройство на ОС Android
  * 0x02 - Мобильное устройство на ОС iOS

#### CRC16

* Примеры вычисления контрольной суммы CRC16. 

На языке C#:
````csharp
/// CRC16 calculation
public static ushort Crc16(byte[] buffer, long index, long count)
{
    int crc = 0xFFFF;

    for (long i = index; i < index + count; i++)
    {
        crc = crc ^ buffer[i];

        for (int j = 0; j < 8; ++j)
        {
            if ((crc & 0x01) == 1)
                crc = (crc >> 1 ^ 0xA001);
            else
                crc >>= 1;
        }
    }
    return (ushort)crc;
}
````
